words_replacer

Приложение для поиска и замены подстрок в файлах, содержащихся в указанном каталоге и его подкаталогах. Путь к каталогу указывается в конфигурационном файле, также там указывается число потоков и список подстановок, сопоставлений шаблонов и строк на их замену.

Пример конфигурационного файла config.ini:

threads_num:8
work_path:/home/files/Documents/auto/1
replacing_table:
<%COLOR%>;RED
n;--<>--
из;----
http;80+8080

В этом примере задано число потоков 8, путь к каталогу для поиска /home/files/Documents/auto/1, а также список подстановок - по одной в каждой строке (число их ограничивается последней строкой, размер файла произвольный), в формате:
[шаблон];[строка_замены]

Алгоритм проверен на ноутбуке с CPU Intel Core-i7 2.6 GHz с 4 ядрами и 8 потоками (по 2 на ядро ~HyperThreading)
Результат:

Набор 1 - 1675 файлов общим размером 190,1 MB (включая 2 больших файла PDF - 58 и 65,2 MB) - проценты приростов скорости выполнения относительно варианта с последовательным выполнением (его время выполнения ~49 сек) с применением потоков STL и распараллеливания OpenMP (std::thread / OMP):
2 потока - 14,3% / 20,4%
4 потока - 30,6% / 30,6%
8 потоков - 30,6% / 30,6%

Набор 2 - 570 файлов общим размером 1,3 GB (файлы различных размеров от 13 KB до 148 MB) - проценты приростов скорости выполнения относительно варианта с последовательным выполнением (его время выполнения ~154 сек) с применением потоков STL и распараллеливания OpenMP (std::thread / OMP):
2 потока - 27,3% / 42,5%
4 потока - 48,7% / 62,3%
8 потоков - 63,6% / 73,4%

Набор 1 достаточно специфичен, неоднороден по размеру файлов, в отличие от набора 2. Возможно, поэтому скорость выполнения прораммы и с применением потоков STL, и с применением OpenMP практически одна и та же и на ~30% превышает скорость алгоритма в его последовательном варианте. В наборе 2 механизм OpenMP сработал лучше, но не в разы и с увеличением числа потоков разрыв между скоростями их выполнения заметно сокращается. OpenMP позволяет непосредственно оперировать не только числом логических потоков, но и распределением их между физическими потоками на ядрах CPU. С другой стороны, потоки STL таких возможностей пока не поддерживают. Более того:
"К этому моменту мы не контролируем следующие детали:
- порядок, в котором потоки чередуются на одном ядре;
- приоритет потока, указывающий, что один поток главнее другого;
- распределение потоков между ядрами.
Вполне возможна ситуация, когда все потоки будут выполняться на одном ядре, несмотря на то что машина имеет более 100 ядер. Большая часть операционных систем предоставляет возможности управления этими аспектами многопроцессорной обработки, но на текущий момент данные функции не включены в STL..." [цитата из книги: Галовиц Я. С++17 STL. Стандартная библиотека шаблонов. — СПб.: Питер, 2018. - с.355]

Для выбора варианта компиляции программы (последовательное / многопоточное std::thread / многопоточное OpenMP) используются макросы parallel_cfg_omp и parallel_cfg_std_thread
